# E2E Testing Framework for Commons-DB

**Status**: Draft
**Created**: 2025-10-15
**Scope**: Large
**Estimated Effort**: 30-42 hours
**Test Framework**: Ginkgo/Gomega

## Revision History

| Date | Author | Changes |
|------|--------|---------|
| 2025-10-15 | Initial | First draft based on discovery phase with Ginkgo framework |

---

## 1. Problem Statement

Commons-db is a critical shared library extracted from flanksource/duty that provides:
- **Log backend integrations**: OpenSearch, Loki, Kubernetes, CloudWatch, GCP Cloud Logging, BigQuery
- **Secret management**: Secure handling of sensitive data
- **Connection abstractions**: S3, SFTP, SMB, GCS, Azure, Kubernetes, Git, HTTP
- **Query grammar**: Powerful search and filtering DSL for catalog items

**Current State**: The package has minimal unit tests (primarily in `logs/opensearch/search_test.go`) but **no end-to-end testing infrastructure**. This creates significant risks:
- Integration issues with real services go undetected until production
- Breaking changes in log backends aren't caught during development
- Connection implementations can't be verified against actual services
- Query grammar correctness relies entirely on manual testing
- Refactoring is risky without comprehensive integration coverage

**Desired State**: Comprehensive e2e testing framework that:
- Validates all backends against real services (not mocks)
- Runs automatically in CI/CD pipeline with every PR
- Can be executed locally by developers with single command
- Provides fast feedback (< 10 minutes total runtime)
- Uses lightweight, reproducible service dependencies
- Follows Ginkgo BDD testing patterns for clarity

---

## 2. Requirements

### Functional Requirements

**FR-1: Test all log backends**
- OpenSearch: log ingestion, search by field, label extraction, JSON field preprocessing
- Loki: log query with LogQL, label filtering, time range queries
- Kubernetes: pod log retrieval via API, namespace filtering, container selection
- CloudWatch Logs: log stream creation, event ingestion, filtering (via LocalStack)
- GCP Cloud Logging: basic log write/read (via gcloud emulator if available)
- BigQuery: query execution (via gcloud emulator if available)

**FR-2: Test all connection types**
- S3: bucket operations, object CRUD, multipart uploads (via LocalStack)
- SFTP: file upload/download, directory listing, permissions (via Docker)
- SMB: file operations, share access (via Docker)
- GCS: bucket and object operations (via fake-gcs-server)
- Azure Blob Storage: container and blob operations (via Azurite)
- Kubernetes: resource CRUD operations (via envtest)
- Git: clone, fetch, authentication
- HTTP: GET/POST with authentication

**FR-3: Test query grammar**
- Parse field queries: `type=value`, `field>=number`, `field!=value`
- Parse wildcards: `name=prefix*`, `*suffix`, `*contains*`
- Parse date math: `created_at>now-24h`, `updated_at<2025-01-01`
- Parse label selectors: `label.key=value`, `labelSelector="key in (a,b)"`
- Parse complex queries: `(field1=a field2=b) | field3=c`
- Execute queries against postgres test data
- Validate result correctness and ordering

**FR-4: Test secret management**
- Secret retrieval and caching
- Sensitive data redaction
- SecretKeeper interface implementations

### Non-Functional Requirements

**NFR-1: Performance** - E2E test suite completes in < 10 minutes
**NFR-2: Reliability** - Zero flaky tests, 100% deterministic outcomes
**NFR-3: Portability** - Runs on macOS (local dev) and Linux (CI)
**NFR-4: Resource Efficiency** - Uses < 4GB RAM for all services combined
**NFR-5: Maintainability** - Clear service lifecycle management, easy debugging
**NFR-6: CI Integration** - Runs in GitHub Actions without cloud credentials
**NFR-7: Test Clarity** - BDD style with Ginkgo/Gomega for readable specs

---

## 3. Design

### 3.1 Architecture

```
commons-db/
‚îú‚îÄ‚îÄ e2e/
‚îÇ   ‚îú‚îÄ‚îÄ deps.yaml                   # Flanksource deps configuration
‚îÇ   ‚îú‚îÄ‚îÄ e2e_suite_test.go           # Ginkgo test suite setup
‚îÇ   ‚îú‚îÄ‚îÄ helpers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services.go             # Service lifecycle (start/stop/health)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services_test.go        # Ginkgo specs for service manager
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ docker.go               # Docker container management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ docker_test.go          # Ginkgo specs for Docker manager
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fixtures.go             # Test data generation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ assertions.go           # Custom Gomega matchers
‚îÇ   ‚îú‚îÄ‚îÄ logs_test.go                # Ginkgo specs for log backends
‚îÇ   ‚îú‚îÄ‚îÄ connections_test.go         # Ginkgo specs for connections
‚îÇ   ‚îú‚îÄ‚îÄ secrets_test.go             # Ginkgo specs for secrets
‚îÇ   ‚îú‚îÄ‚îÄ query_test.go               # Ginkgo specs for query grammar
‚îÇ   ‚îî‚îÄ‚îÄ README.md                   # Setup and usage documentation
‚îî‚îÄ‚îÄ .github/workflows/
    ‚îî‚îÄ‚îÄ e2e.yml                     # CI configuration
```

### 3.2 Service Dependencies

#### Native Binaries (via flanksource/deps)

**Postgres** ‚úÖ (already in deps)
- **Manager**: `maven`
- **Purpose**: Database for test fixtures and query testing
- **Source**: `io.zonky.test.postgres` embedded binaries
- **Version**: 16.1.0
- **Platforms**: darwin-amd64, darwin-arm64, linux-amd64, linux-arm64

**Redis** üÜï (to be added to deps)
- **Manager**: `direct`
- **Purpose**: Caching, pub/sub testing, connection pooling
- **URL Template**: `https://download.redis.io/releases/redis-{{.version}}.tar.gz`
- **Version**: 7.2.x (stable)
- **Platforms**: darwin-amd64, darwin-arm64, linux-amd64, linux-arm64
- **Build**: Requires `make` during post-process
- **Binary Path**: `src/redis-server`

**OpenSearch** üÜï (to be added to deps)
- **Manager**: `direct`
- **Purpose**: Log backend testing with full-text search
- **URL Template**: `https://artifacts.opensearch.org/releases/bundle/opensearch/{{.version}}/opensearch-{{.version}}-{{.os}}-{{.arch}}.tar.gz`
- **Version**: 2.11.x (latest 2.x stable)
- **Platforms**: darwin-x64, darwin-arm64, linux-x64, linux-arm64
- **Mode**: `directory`
- **Symlinks**: `bin/opensearch`, `bin/opensearch-plugin`
- **Requirements**: JDK 11+ (bundled in distribution)
- **Config**: Use minimal cluster setup (single node, no SSL)

**Loki** üÜï (to be added to deps)
- **Manager**: `github_release`
- **Repo**: `grafana/loki`
- **Purpose**: Log aggregation and LogQL querying
- **Asset Patterns**: `loki-{{.os}}-{{.arch}}.zip`
- **Version**: 2.9.x (latest 2.x)
- **Platforms**: darwin-amd64, darwin-arm64, linux-amd64, linux-arm64
- **Binary Name**: `loki`

**LocalStack CLI** üÜï (to be added to deps)
- **Manager**: `github_release`
- **Repo**: `localstack/localstack-cli`
- **Purpose**: AWS service emulation (S3, SQS, CloudWatch Logs)
- **Asset Patterns**: `localstack-cli-{{.version}}-{{.os}}-{{.arch}}.tar.gz`
- **Version**: 3.0.x (latest)
- **Platforms**: darwin-amd64, darwin-arm64, linux-amd64, linux-arm64
- **Binary Name**: `localstack`
- **Services**: S3, SQS, CloudWatch Logs, IAM (basic)

**envtest** ‚úÖ (already in deps)
- **Purpose**: Kubernetes API server + etcd for testing
- **Already configured**: Yes
- **Version**: Tracks Kubernetes releases

#### Docker Containers (managed by test code)

**SFTP Server**
- **Image**: `atmoz/sftp:latest`
- **Purpose**: SFTP connection testing
- **Port**: 2222 (mapped from container port 22)
- **Credentials**: `test:test` (username:password)
- **Volume**: Temporary directory for uploads
- **Config**: Allow password authentication

**SMB Server**
- **Image**: `filesysorg/jfileserver:latest`
- **Purpose**: SMB/CIFS connection testing
- **Port**: 445
- **Credentials**: Guest access enabled
- **Volume**: Shared directory for test files

**Fake GCS Server**
- **Image**: `fsouza/fake-gcs-server:latest`
- **Purpose**: Google Cloud Storage emulation
- **Port**: 4443 (HTTP mode)
- **Storage**: In-memory
- **Config**: `-scheme http -public-host localhost:4443`

**Azurite**
- **Image**: `mcr.microsoft.com/azure-storage/azurite:latest`
- **Purpose**: Azure Blob Storage, Queue, and Table emulation
- **Ports**:
  - 10000 (Blob service)
  - 10001 (Queue service)
  - 10002 (Table service)
- **Storage**: In-memory
- **Account**: Default development account credentials

### 3.3 Ginkgo Test Organization

#### Test Suite Structure

**e2e/e2e_suite_test.go** - Suite setup and teardown:

```go
package e2e

import (
    "context"
    "testing"

    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"

    "github.com/flanksource/commons-db/e2e/helpers"
)

func TestE2E(t *testing.T) {
    RegisterFailHandler(Fail)
    RunSpecs(t, "Commons-DB E2E Suite")
}

var (
    serviceManager *helpers.ServiceManager
    dockerManager  *helpers.DockerManager
    ctx            context.Context
)

var _ = BeforeSuite(func() {
    GinkgoWriter.Println("Starting Commons-DB E2E test suite")

    ctx = context.Background()

    // Initialize service managers
    serviceManager = helpers.NewServiceManager()
    dockerManager = helpers.NewDockerManager()

    // Start all native services
    GinkgoWriter.Println("Starting native services (Postgres, Redis, OpenSearch, Loki, LocalStack)...")
    Expect(serviceManager.StartAll(ctx)).To(Succeed())

    // Start Docker containers
    GinkgoWriter.Println("Starting Docker containers (SFTP, SMB, GCS, Azurite)...")
    Expect(dockerManager.StartAll(ctx)).To(Succeed())

    // Wait for all services to be healthy
    GinkgoWriter.Println("Waiting for all services to become healthy...")
    Eventually(func() bool {
        return serviceManager.AllHealthy() && dockerManager.AllHealthy()
    }, "2m", "5s").Should(BeTrue())

    GinkgoWriter.Println("All services ready")
})

var _ = AfterSuite(func() {
    GinkgoWriter.Println("Cleaning up E2E test suite")

    if dockerManager != nil {
        Expect(dockerManager.StopAll(ctx)).To(Succeed())
    }

    if serviceManager != nil {
        Expect(serviceManager.StopAll(ctx)).To(Succeed())
    }

    GinkgoWriter.Println("Cleanup complete")
})
```

#### Individual Test Files

**e2e/logs_test.go** - Log backend tests:

```go
var _ = Describe("Log Backends", func() {
    Describe("OpenSearch", func() {
        var searcher *opensearch.Searcher

        BeforeEach(func() {
            cfg := &opensearch.Config{
                URL: serviceManager.OpenSearchURL(),
            }
            searcher = opensearch.NewSearcher(cfg)
        })

        Context("when ingesting logs", func() {
            It("should successfully ingest 100 log entries", func() {
                logs := helpers.GenerateTestLogs(100)
                err := helpers.IngestToOpenSearch(searcher, logs)
                Expect(err).NotTo(HaveOccurred())
            })
        })

        Context("when searching logs", func() {
            It("should find logs by exact field match", func() {
                results, err := searcher.Search(ctx, opensearch.SearchRequest{
                    Query: "level=error",
                    Size:  10,
                })
                Expect(err).NotTo(HaveOccurred())
                Expect(results.Logs).To(HaveLen(10))

                for _, log := range results.Logs {
                    Expect(log.Labels).To(HaveKeyWithValue("level", "error"))
                }
            })

            It("should support wildcard searches", func() {
                results, err := searcher.Search(ctx, opensearch.SearchRequest{
                    Query: "message=database*",
                    Size:  50,
                })
                Expect(err).NotTo(HaveOccurred())

                for _, log := range results.Logs {
                    Expect(log.Message).To(HavePrefix("database"))
                }
            })
        })
    })

    Describe("Loki", func() {
        // Similar structure for Loki
    })

    Describe("Kubernetes Logs", func() {
        // Tests using envtest
    })

    Describe("CloudWatch Logs", func() {
        // Tests using LocalStack
    })
})
```

**e2e/connections_test.go** - Connection tests:

```go
var _ = Describe("Connections", func() {
    Describe("SFTP", func() {
        var conn *connection.SFTPConnection

        BeforeEach(func() {
            conn = &connection.SFTPConnection{
                Host:     "localhost",
                Port:     dockerManager.SFTPPort(),
                Username: "test",
                Password: "test",
            }
        })

        It("should connect successfully", func() {
            err := conn.Connect(ctx)
            Expect(err).NotTo(HaveOccurred())
        })

        Context("when performing file operations", func() {
            var testData []byte

            BeforeEach(func() {
                testData = []byte("test file content\n")
            })

            It("should upload a file", func() {
                err := conn.Upload(ctx, "/test.txt", testData)
                Expect(err).NotTo(HaveOccurred())
            })

            It("should download the uploaded file", func() {
                err := conn.Upload(ctx, "/download-test.txt", testData)
                Expect(err).NotTo(HaveOccurred())

                downloaded, err := conn.Download(ctx, "/download-test.txt")
                Expect(err).NotTo(HaveOccurred())
                Expect(downloaded).To(Equal(testData))
            })

            It("should list files in directory", func() {
                // Upload multiple files
                Expect(conn.Upload(ctx, "/list-1.txt", testData)).To(Succeed())
                Expect(conn.Upload(ctx, "/list-2.txt", testData)).To(Succeed())

                files, err := conn.List(ctx, "/")
                Expect(err).NotTo(HaveOccurred())
                Expect(files).To(ContainElements("list-1.txt", "list-2.txt"))
            })

            It("should delete a file", func() {
                err := conn.Upload(ctx, "/delete-test.txt", testData)
                Expect(err).NotTo(HaveOccurred())

                err = conn.Delete(ctx, "/delete-test.txt")
                Expect(err).NotTo(HaveOccurred())

                // Verify file no longer exists
                _, err = conn.Download(ctx, "/delete-test.txt")
                Expect(err).To(HaveOccurred())
            })
        })
    })

    Describe("S3 via LocalStack", func() {
        // Similar BDD structure for S3
    })

    Describe("SMB", func() {
        // SMB tests
    })

    Describe("GCS via fake-gcs-server", func() {
        // GCS tests
    })

    Describe("Azure via Azurite", func() {
        // Azure tests
    })
})
```

**e2e/query_test.go** - Query grammar tests:

```go
var _ = Describe("Query Grammar", func() {
    Describe("Parsing", func() {
        Context("with simple field queries", func() {
            It("should parse type=value", func() {
                parsed, err := query.Parse("type=Kubernetes::Pod")
                Expect(err).NotTo(HaveOccurred())
                Expect(parsed.Fields).To(HaveKeyWithValue("type", "Kubernetes::Pod"))
            })

            It("should parse multiple fields", func() {
                parsed, err := query.Parse("type=Pod name=nginx namespace=default")
                Expect(err).NotTo(HaveOccurred())
                Expect(parsed.Fields).To(HaveLen(3))
            })
        })

        Context("with operators", func() {
            DescribeTable("should parse comparison operators",
                func(query string, expectedOp string, expectedValue string) {
                    parsed, err := query.Parse(query)
                    Expect(err).NotTo(HaveOccurred())
                    // Verify operator and value
                },
                Entry("greater than", "age>5", ">", "5"),
                Entry("less than", "age<10", "<", "10"),
                Entry("greater than or equal", "age>=5", ">=", "5"),
                Entry("not equal", "status!=failed", "!=", "failed"),
            )
        })

        Context("with wildcards", func() {
            // Wildcard tests
        })

        Context("with date math", func() {
            // Date math tests
        })
    })

    Describe("Execution", func() {
        BeforeEach(func() {
            // Seed database with test data
        })

        Context("against postgres", func() {
            It("should filter by field", func() {
                results, err := query.Execute(ctx, "type=Pod")
                Expect(err).NotTo(HaveOccurred())
                Expect(results).NotTo(BeEmpty())

                for _, r := range results {
                    Expect(r.Type).To(Equal("Pod"))
                }
            })
        })
    })
})
```

### 3.4 Service Lifecycle Management

**e2e/helpers/services.go** - Native service management (< 400 lines):

```go
package helpers

import (
    "context"
    "fmt"
    "os/exec"
    "time"
)

type ServiceManager struct {
    binDir     string
    dataDir    string
    postgres   *PostgresService
    redis      *RedisService
    opensearch *OpenSearchService
    loki       *LokiService
    localstack *LocalStackService
}

func NewServiceManager() *ServiceManager {
    return &ServiceManager{
        binDir:  "./.bin",
        dataDir: "./.data",
    }
}

func (sm *ServiceManager) StartAll(ctx context.Context) error {
    services := []Service{
        sm.postgres,
        sm.redis,
        sm.opensearch,
        sm.loki,
        sm.localstack,
    }

    for _, svc := range services {
        if err := svc.Start(ctx); err != nil {
            return fmt.Errorf("failed to start %s: %w", svc.Name(), err)
        }
    }

    return sm.WaitForHealthy(ctx)
}

func (sm *ServiceManager) StopAll(ctx context.Context) error {
    // Stop in reverse order
    // Handle errors gracefully
}

func (sm *ServiceManager) AllHealthy() bool {
    // Check health of all services
}

type Service interface {
    Name() string
    Start(ctx context.Context) error
    Stop(ctx context.Context) error
    IsHealthy() bool
    URL() string
}

type PostgresService struct {
    cmd  *exec.Cmd
    port int
}

// Implement Service interface...
```

**e2e/helpers/docker.go** - Docker container management (< 400 lines):

```go
package helpers

import (
    "context"
    "github.com/docker/go-connections/nat"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/wait"
)

type DockerManager struct {
    sftp    testcontainers.Container
    smb     testcontainers.Container
    gcs     testcontainers.Container
    azurite testcontainers.Container
}

func NewDockerManager() *DockerManager {
    return &DockerManager{}
}

func (dm *DockerManager) StartAll(ctx context.Context) error {
    if err := dm.StartSFTP(ctx); err != nil {
        return err
    }
    if err := dm.StartSMB(ctx); err != nil {
        return err
    }
    if err := dm.StartFakeGCS(ctx); err != nil {
        return err
    }
    if err := dm.StartAzurite(ctx); err != nil {
        return err
    }
    return nil
}

func (dm *DockerManager) StartSFTP(ctx context.Context) error {
    req := testcontainers.ContainerRequest{
        Image:        "atmoz/sftp:latest",
        ExposedPorts: []string{"22/tcp"},
        Env: map[string]string{
            "SFTP_USERS": "test:test:1001",
        },
        WaitingFor: wait.ForListeningPort("22/tcp"),
    }

    container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: req,
        Started:          true,
    })

    if err != nil {
        return fmt.Errorf("failed to start SFTP container: %w", err)
    }

    dm.sftp = container
    return nil
}

func (dm *DockerManager) SFTPPort() int {
    port, _ := dm.sftp.MappedPort(context.Background(), "22")
    return port.Int()
}

func (dm *DockerManager) StopAll(ctx context.Context) error {
    // Cleanup all containers
}
```

### 3.5 Custom Gomega Matchers

**e2e/helpers/assertions.go** - Custom matchers (< 200 lines):

```go
package helpers

import (
    "github.com/onsi/gomega/types"
)

// HaveLogWithLevel creates a matcher for checking log level
func HaveLogWithLevel(level string) types.GomegaMatcher {
    return &logLevelMatcher{expectedLevel: level}
}

type logLevelMatcher struct {
    expectedLevel string
}

func (m *logLevelMatcher) Match(actual interface{}) (bool, error) {
    logs, ok := actual.([]LogEntry)
    if !ok {
        return false, fmt.Errorf("expected []LogEntry, got %T", actual)
    }

    for _, log := range logs {
        if log.Labels["level"] == m.expectedLevel {
            return true, nil
        }
    }
    return false, nil
}

func (m *logLevelMatcher) FailureMessage(actual interface{}) string {
    return fmt.Sprintf("Expected to find log with level %s", m.expectedLevel)
}

func (m *logLevelMatcher) NegatedFailureMessage(actual interface{}) string {
    return fmt.Sprintf("Expected not to find log with level %s", m.expectedLevel)
}
```

---

## 4. Acceptance Criteria

### AC-1: Deps Contributions
- ‚úÖ Redis package added to flanksource/deps default registry
- ‚úÖ OpenSearch package added to flanksource/deps default registry
- ‚úÖ Loki package added to flanksource/deps default registry
- ‚úÖ LocalStack CLI package added to flanksource/deps default registry
- ‚úÖ All packages install successfully on darwin-arm64 and linux-amd64
- ‚úÖ All packages pass version verification tests
- ‚úÖ Packages merged into deps main branch (or available in local deps.yaml)

### AC-2: E2E Infrastructure with Ginkgo
- ‚úÖ `e2e/` directory created with Ginkgo test suite
- ‚úÖ `e2e/e2e_suite_test.go` implements BeforeSuite/AfterSuite
- ‚úÖ `e2e/deps.yaml` installs all required services
- ‚úÖ Service manager starts/stops all native services reliably
- ‚úÖ Docker manager handles all container services
- ‚úÖ Health checks validate service readiness with retries
- ‚úÖ Cleanup handles errors gracefully (no orphaned processes/containers)
- ‚úÖ Ginkgo reporter configured for clear test output

### AC-3: Log Backend Tests (Ginkgo Specs)
- ‚úÖ OpenSearch: `Describe("OpenSearch")` with Context for each operation
  - Ingest logs, search by field, retrieve by ID, JSON field preprocessing
- ‚úÖ Loki: Query logs with LogQL, filter by labels, time range queries
- ‚úÖ Kubernetes: Retrieve pod logs via API using envtest
- ‚úÖ CloudWatch via LocalStack: Write and read log streams
- ‚úÖ GCP emulator: Basic log write/read (if emulator available)
- ‚úÖ BigQuery emulator: Basic query (if emulator available)
- ‚úÖ All tests use Gomega matchers (Expect, Eventually)
- ‚úÖ All tests use real service connections (no mocks)

### AC-4: Connection Tests (Ginkgo Specs)
- ‚úÖ SFTP: `Describe("SFTP")` with Context for file operations
  - Connect, upload, download, delete, list files
- ‚úÖ S3: Create bucket, put object, get object, list objects (via LocalStack)
- ‚úÖ SMB: Connect, read/write files, list directories
- ‚úÖ GCS: Create bucket, upload/download objects (via fake-gcs-server)
- ‚úÖ Azure: Connect to blob storage, basic operations (via Azurite)
- ‚úÖ Kubernetes: Create/read/update/delete resources (via envtest)
- ‚úÖ All tests use Gomega matchers

### AC-5: Query Grammar Tests (Ginkgo Specs)
- ‚úÖ Parse field queries: `type=value`, `field>=number`
- ‚úÖ Parse wildcards: `name=prefix*`, `*suffix`, `*contains*`
- ‚úÖ Parse date math: `created_at>now-24h`, `updated_at<now-7d`
- ‚úÖ Parse label selectors: `label.key=value`
- ‚úÖ Parse complex queries: `(field1=a field2=b) | field3=c`
- ‚úÖ Execute queries against postgres test data
- ‚úÖ Validate result correctness and ordering
- ‚úÖ Use DescribeTable for parameterized tests

### AC-6: CI Integration
- ‚úÖ GitHub Actions workflow runs Ginkgo specs with `-v` flag
- ‚úÖ Tests pass on ubuntu-latest runner
- ‚úÖ Test artifacts uploaded on failure
- ‚úÖ Ginkgo JUnit XML reports generated
- ‚úÖ Test results reported in PR comments
- ‚úÖ Workflow completes in < 15 minutes

### AC-7: Documentation
- ‚úÖ README.md in e2e/ with setup instructions
- ‚úÖ Document how to run tests locally: `ginkgo -v ./e2e`
- ‚úÖ Document how to run specific specs: `ginkgo -v -focus="OpenSearch" ./e2e`
- ‚úÖ Document how to debug test failures
- ‚úÖ Document service port assignments

---

## 5. Implementation Plan

### Phase 1: Deps Contributions (8-12 hours)

**Step 1.1: Add Redis to deps** (2-3 hours)

**Tasks**:
1. Research Redis binary distribution
2. Create package definition in `deps/pkg/config/defaults.yaml`
3. Define URL template and asset patterns
4. Add post-process for compilation
5. Test locally

**Package Definition**:
```yaml
redis:
  name: redis
  manager: direct
  mode: directory
  url_template: https://download.redis.io/releases/redis-{{.version}}.tar.gz
  asset_patterns:
    "*": redis-{{.version}}.tar.gz
  version_command: src/redis-server --version
  version_pattern: 'Redis server v=(\d+\.\d+\.\d+)'
  post_process:
    - make -j4
  symlinks:
    - src/redis-server
    - src/redis-cli
```

**Verification**:
```bash
cd /Users/moshe/go/src/github.com/flanksource/deps
# Edit pkg/config/defaults.yaml
deps install redis:7.2.4
.bin/redis-server --version
```

**Expected Output**: `Redis server v=7.2.4 sha=00000000:0 malloc=libc ...`

**Test Cases** (deps e2e):
```go
var _ = Describe("Redis Package", func() {
    It("should install successfully", func() {
        result, err := deps.Install("redis", "7.2.4",
            deps.WithBinDir(testDir))
        Expect(err).NotTo(HaveOccurred())
        Expect(result.Status).To(Equal(types.InstallStatusInstalled))
    })

    It("should verify version correctly", func() {
        // Version verification test
    })
})
```

**Git**:
```bash
git add pkg/config/defaults.yaml
git commit -m "feat(registry): add Redis package for all platforms

- Supports Redis 7.2.x with native compilation
- Works on darwin-amd64, darwin-arm64, linux-amd64, linux-arm64
- Includes redis-server and redis-cli binaries"
```

**Step 1.2: Add OpenSearch to deps** (2-3 hours)

**Package Definition**:
```yaml
opensearch:
  name: opensearch
  manager: direct
  mode: directory
  url_template: https://artifacts.opensearch.org/releases/bundle/opensearch/{{.version}}/opensearch-{{.version}}-{{.os}}-{{.arch}}.tar.gz
  asset_patterns:
    darwin-amd64: opensearch-{{.version}}-darwin-x64.tar.gz
    darwin-arm64: opensearch-{{.version}}-darwin-arm64.tar.gz
    linux-amd64: opensearch-{{.version}}-linux-x64.tar.gz
    linux-arm64: opensearch-{{.version}}-linux-arm64.tar.gz
  version_command: bin/opensearch --version
  version_pattern: 'Version: (\d+\.\d+\.\d+)'
  symlinks:
    - bin/opensearch
    - bin/opensearch-plugin
  post_process:
    # Disable security for testing
    - 'echo "plugins.security.disabled: true" >> config/opensearch.yml'
```

**Verification**:
```bash
deps install opensearch:2.11.1
.bin/opensearch --version
```

**Git**:
```bash
git add pkg/config/defaults.yaml
git commit -m "feat(registry): add OpenSearch package with JVM

- OpenSearch 2.11.x with bundled JDK
- Single node configuration for testing
- Security plugin disabled by default"
git tag wip-compile
```

**Step 1.3: Add Loki to deps** (2-3 hours)

**Package Definition**:
```yaml
loki:
  name: loki
  repo: grafana/loki
  manager: github_release
  asset_patterns:
    darwin-amd64: loki-darwin-amd64.zip
    darwin-arm64: loki-darwin-arm64.zip
    linux-amd64: loki-linux-amd64.zip
    linux-arm64: loki-linux-arm64.zip
  version_command: --version
  version_pattern: 'loki, version (\d+\.\d+\.\d+)'
  checksum_file: SHA256SUMS
```

**Verification**:
```bash
deps install loki:2.9.3
.bin/loki --version
```

**Git**:
```bash
git add pkg/config/defaults.yaml
git commit -m "feat(registry): add Loki log aggregation system

- Loki 2.9.x from Grafana Labs
- Supports LogQL query language
- Lightweight log aggregation for testing"
```

**Step 1.4: Add LocalStack CLI to deps** (2-3 hours)

**Package Definition**:
```yaml
localstack:
  name: localstack
  repo: localstack/localstack-cli
  manager: github_release
  asset_patterns:
    darwin-amd64: localstack-cli-{{.version}}-darwin-amd64.tar.gz
    darwin-arm64: localstack-cli-{{.version}}-darwin-arm64.tar.gz
    linux-amd64: localstack-cli-{{.version}}-linux-amd64.tar.gz
    linux-arm64: localstack-cli-{{.version}}-linux-arm64.tar.gz
  version_command: --version
  version_pattern: 'localstack (\d+\.\d+\.\d+)'
```

**Verification**:
```bash
deps install localstack:3.0.2
.bin/localstack --version
.bin/localstack start -d
aws --endpoint-url=http://localhost:4566 s3 mb s3://test-bucket
```

**Git**:
```bash
git add pkg/config/defaults.yaml
git commit -m "feat(registry): add LocalStack CLI for AWS emulation

- LocalStack 3.x for S3, SQS, CloudWatch
- Supports local AWS service testing
- No cloud credentials required"
git tag wip-compile
```

**Step 1.5: Create upstream PR or use local** (1-2 hours)

**Option A: Upstream PR**
```bash
cd /Users/moshe/go/src/github.com/flanksource/deps
git checkout -b add-e2e-services
git push origin add-e2e-services
gh pr create --title "feat: add Redis, OpenSearch, Loki, LocalStack for e2e testing" \
  --body "Adds 4 new packages to support e2e testing in flanksource projects"
```

**Option B: Local deps.yaml**
If upstream PR is delayed, add to commons-db's local deps.yaml:
```bash
cd /Users/moshe/go/src/github.com/flanksource/commons-db/e2e
# Create deps.yaml with local registry definitions
```

---

### Phase 2: E2E Infrastructure with Ginkgo (6-8 hours)

**Step 2.1: Create e2e directory structure** (30 min)

```bash
cd /Users/moshe/go/src/github.com/flanksource/commons-db
mkdir -p e2e/helpers
touch e2e/e2e_suite_test.go
touch e2e/logs_test.go
touch e2e/connections_test.go
touch e2e/secrets_test.go
touch e2e/query_test.go
touch e2e/helpers/services.go
touch e2e/helpers/services_test.go
touch e2e/helpers/docker.go
touch e2e/helpers/docker_test.go
touch e2e/helpers/fixtures.go
touch e2e/helpers/assertions.go
touch e2e/deps.yaml
touch e2e/README.md
touch e2e/.gitignore
```

**e2e/.gitignore**:
```
.bin/
.cache/
.data/
*.log
test-results/
```

**Git**:
```bash
git add e2e/
git commit -m "feat(e2e): create initial directory structure with Ginkgo

- Set up e2e test directory
- Add Ginkgo test suite files
- Add helpers for service management"
```

**Step 2.2: Initialize Ginkgo suite** (30 min)

**File**: `e2e/e2e_suite_test.go`
```go
package e2e

import (
    "context"
    "testing"

    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"

    "github.com/flanksource/commons-db/e2e/helpers"
)

func TestE2E(t *testing.T) {
    RegisterFailHandler(Fail)
    RunSpecs(t, "Commons-DB E2E Suite")
}

var (
    serviceManager *helpers.ServiceManager
    dockerManager  *helpers.DockerManager
    ctx            context.Context
)

var _ = BeforeSuite(func() {
    GinkgoWriter.Println("üöÄ Starting Commons-DB E2E test suite")

    ctx = context.Background()

    serviceManager = helpers.NewServiceManager()
    dockerManager = helpers.NewDockerManager()

    GinkgoWriter.Println("üì¶ Starting native services...")
    Expect(serviceManager.StartAll(ctx)).To(Succeed())

    GinkgoWriter.Println("üê≥ Starting Docker containers...")
    Expect(dockerManager.StartAll(ctx)).To(Succeed())

    GinkgoWriter.Println("‚è≥ Waiting for services to be healthy...")
    Eventually(func() bool {
        return serviceManager.AllHealthy() && dockerManager.AllHealthy()
    }, "2m", "5s").Should(BeTrue())

    GinkgoWriter.Println("‚úÖ All services ready")
})

var _ = AfterSuite(func() {
    GinkgoWriter.Println("üßπ Cleaning up E2E test suite")

    if dockerManager != nil {
        Expect(dockerManager.StopAll(ctx)).To(Succeed())
    }

    if serviceManager != nil {
        Expect(serviceManager.StopAll(ctx)).To(Succeed())
    }

    GinkgoWriter.Println("‚úÖ Cleanup complete")
})
```

**Verification**:
```bash
cd e2e
go mod init github.com/flanksource/commons-db/e2e || true
go get github.com/onsi/ginkgo/v2@latest
go get github.com/onsi/gomega@latest
ginkgo bootstrap
```

**Git**:
```bash
git add e2e/e2e_suite_test.go e2e/go.mod e2e/go.sum
git commit -m "feat(e2e): initialize Ginkgo test suite

- Add BeforeSuite for service startup
- Add AfterSuite for cleanup
- Configure Ginkgo reporter"
```

**Step 2.3: Create deps.yaml** (30 min)

**File**: `e2e/deps.yaml`
```yaml
dependencies:
  postgres: "16.1.0"
  redis: "7.2.4"
  opensearch: "2.11.1"
  loki: "2.9.3"
  localstack: "3.0.2"
  envtest: "v1.28.0"

settings:
  bin_dir: ./.bin
  app_dir: ./.apps
  cache_dir: ./.cache
  parallel: true
```

**Verification**:
```bash
cd e2e
deps install
ls -la .bin/
# Should see: postgres, redis-server, opensearch, loki, localstack
```

**Git**:
```bash
git add e2e/deps.yaml
git commit -m "feat(e2e): add deps configuration for all services

- Configure Postgres, Redis, OpenSearch, Loki, LocalStack
- Set custom bin and cache directories
- Enable parallel installation"
```

**Step 2.4: Implement service lifecycle manager** (2-3 hours)

**File**: `e2e/helpers/services.go` (< 400 lines)

See detailed implementation in Architecture section 3.4.

**Key Functions**:
- `NewServiceManager()` - Initialize with default paths
- `StartAll(ctx)` - Start all services sequentially
- `StopAll(ctx)` - Stop all services in reverse order
- `AllHealthy()` - Check health of all services
- Each service implements `Service` interface

**Test File**: `e2e/helpers/services_test.go`

```go
package helpers_test

import (
    "context"
    "testing"

    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"

    "github.com/flanksource/commons-db/e2e/helpers"
)

func TestHelpers(t *testing.T) {
    RegisterFailHandler(Fail)
    RunSpecs(t, "Helpers Suite")
}

var _ = Describe("ServiceManager", func() {
    var sm *helpers.ServiceManager
    var ctx context.Context

    BeforeEach(func() {
        sm = helpers.NewServiceManager()
        ctx = context.Background()
    })

    Describe("StartAll", func() {
        It("should start all services successfully", func() {
            err := sm.StartAll(ctx)
            Expect(err).NotTo(HaveOccurred())
        })

        It("should have all services healthy after start", func() {
            Expect(sm.StartAll(ctx)).To(Succeed())

            Eventually(func() bool {
                return sm.AllHealthy()
            }, "2m", "5s").Should(BeTrue())
        })
    })

    Describe("StopAll", func() {
        It("should stop all services without error", func() {
            Expect(sm.StartAll(ctx)).To(Succeed())
            Expect(sm.StopAll(ctx)).To(Succeed())
        })
    })
})
```

**Verification**:
```bash
cd e2e/helpers
ginkgo -v
```

**Git**:
```bash
git add e2e/helpers/services.go e2e/helpers/services_test.go
git commit -m "feat(e2e): implement native service lifecycle manager

- ServiceManager orchestrates all native services
- Health checks with configurable timeouts
- Graceful shutdown handling
- Ginkgo specs for service manager"
git tag wip-compile
```

**Step 2.5: Implement Docker container manager** (2-3 hours)

**File**: `e2e/helpers/docker.go` (< 400 lines)

```go
package helpers

import (
    "context"
    "fmt"
    "time"

    "github.com/docker/go-connections/nat"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/wait"
)

type DockerManager struct {
    sftp    testcontainers.Container
    smb     testcontainers.Container
    gcs     testcontainers.Container
    azurite testcontainers.Container
}

func NewDockerManager() *DockerManager {
    return &DockerManager{}
}

func (dm *DockerManager) StartAll(ctx context.Context) error {
    if err := dm.StartSFTP(ctx); err != nil {
        return fmt.Errorf("failed to start SFTP: %w", err)
    }
    if err := dm.StartSMB(ctx); err != nil {
        return fmt.Errorf("failed to start SMB: %w", err)
    }
    if err := dm.StartFakeGCS(ctx); err != nil {
        return fmt.Errorf("failed to start GCS: %w", err)
    }
    if err := dm.StartAzurite(ctx); err != nil {
        return fmt.Errorf("failed to start Azurite: %w", err)
    }
    return nil
}

func (dm *DockerManager) StartSFTP(ctx context.Context) error {
    req := testcontainers.ContainerRequest{
        Image:        "atmoz/sftp:latest",
        ExposedPorts: []string{"22/tcp"},
        Env: map[string]string{
            "SFTP_USERS": "test:test:1001",
        },
        WaitingFor: wait.ForListeningPort("22/tcp").WithStartupTimeout(30 * time.Second),
    }

    container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: req,
        Started:          true,
    })

    if err != nil {
        return err
    }

    dm.sftp = container
    return nil
}

func (dm *DockerManager) SFTPPort() int {
    port, _ := dm.sftp.MappedPort(context.Background(), "22")
    return port.Int()
}

func (dm *DockerManager) StartSMB(ctx context.Context) error {
    // Similar implementation
}

func (dm *DockerManager) StartFakeGCS(ctx context.Context) error {
    req := testcontainers.ContainerRequest{
        Image:        "fsouza/fake-gcs-server:latest",
        ExposedPorts: []string{"4443/tcp"},
        Cmd:          []string{"-scheme", "http", "-public-host", "localhost:4443"},
        WaitingFor:   wait.ForHTTP("/").WithPort("4443/tcp"),
    }

    container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: req,
        Started:          true,
    })

    if err != nil {
        return err
    }

    dm.gcs = container
    return nil
}

func (dm *DockerManager) StartAzurite(ctx context.Context) error {
    // Similar implementation
}

func (dm *DockerManager) StopAll(ctx context.Context) error {
    containers := []testcontainers.Container{
        dm.azurite, dm.gcs, dm.smb, dm.sftp,
    }

    for _, c := range containers {
        if c != nil {
            if err := c.Terminate(ctx); err != nil {
                return err
            }
        }
    }
    return nil
}

func (dm *DockerManager) AllHealthy() bool {
    return dm.sftp != nil && dm.smb != nil &&
           dm.gcs != nil && dm.azurite != nil
}
```

**Test File**: `e2e/helpers/docker_test.go`

```go
var _ = Describe("DockerManager", func() {
    var dm *helpers.DockerManager
    var ctx context.Context

    BeforeEach(func() {
        dm = helpers.NewDockerManager()
        ctx = context.Background()
    })

    AfterEach(func() {
        if dm != nil {
            Expect(dm.StopAll(ctx)).To(Succeed())
        }
    })

    Describe("SFTP Container", func() {
        It("should start and expose port", func() {
            err := dm.StartSFTP(ctx)
            Expect(err).NotTo(HaveOccurred())

            port := dm.SFTPPort()
            Expect(port).To(BeNumerically(">", 0))
        })
    })

    Describe("StartAll", func() {
        It("should start all containers", func() {
            err := dm.StartAll(ctx)
            Expect(err).NotTo(HaveOccurred())
            Expect(dm.AllHealthy()).To(BeTrue())
        })
    })
})
```

**Verification**:
```bash
cd e2e/helpers
ginkgo -v -focus="DockerManager"
```

**Git**:
```bash
git add e2e/helpers/docker.go e2e/helpers/docker_test.go
git commit -m "feat(e2e): implement Docker container manager

- Uses testcontainers-go for lifecycle management
- Manages SFTP, SMB, GCS, Azurite containers
- Automatic port mapping and health checks
- Ginkgo specs for Docker manager"
git tag wip-compile
```

**Step 2.6: Create test fixtures and helpers** (1-2 hours)

**File**: `e2e/helpers/fixtures.go` (< 300 lines)

```go
package helpers

import (
    "fmt"
    "math/rand"
    "time"

    "github.com/flanksource/commons-db/logs"
)

type LogEntry struct {
    Message   string
    Timestamp time.Time
    Labels    map[string]string
}

func GenerateTestLogs(count int) []LogEntry {
    levels := []string{"info", "warn", "error", "debug"}
    services := []string{"api", "worker", "scheduler", "webhook"}

    logs := make([]LogEntry, count)
    for i := 0; i < count; i++ {
        logs[i] = LogEntry{
            Message:   fmt.Sprintf("Test log message %d", i),
            Timestamp: time.Now().Add(-time.Duration(i) * time.Minute),
            Labels: map[string]string{
                "level":   levels[rand.Intn(len(levels))],
                "service": services[rand.Intn(len(services))],
                "pod":     fmt.Sprintf("pod-%d", rand.Intn(10)),
            },
        }
    }
    return logs
}

func GenerateTestFile(size int) []byte {
    data := make([]byte, size)
    for i := range data {
        data[i] = byte('a' + (i % 26))
    }
    return data
}
```

**File**: `e2e/helpers/assertions.go` (< 200 lines)

```go
package helpers

import (
    "fmt"

    "github.com/onsi/gomega/types"
)

// HaveLogWithLevel creates matcher for log level
func HaveLogWithLevel(level string) types.GomegaMatcher {
    return &logLevelMatcher{expectedLevel: level}
}

type logLevelMatcher struct {
    expectedLevel string
}

func (m *logLevelMatcher) Match(actual interface{}) (bool, error) {
    logs, ok := actual.([]LogEntry)
    if !ok {
        return false, fmt.Errorf("expected []LogEntry, got %T", actual)
    }

    for _, log := range logs {
        if log.Labels["level"] == m.expectedLevel {
            return true, nil
        }
    }
    return false, nil
}

func (m *logLevelMatcher) FailureMessage(actual interface{}) string {
    return fmt.Sprintf("Expected to find log with level %s", m.expectedLevel)
}

func (m *logLevelMatcher) NegatedFailureMessage(actual interface{}) string {
    return fmt.Sprintf("Expected not to find log with level %s", m.expectedLevel)
}
```

**Git**:
```bash
git add e2e/helpers/fixtures.go e2e/helpers/assertions.go
git commit -m "feat(e2e): add test fixtures and custom matchers

- Generate test logs with realistic labels
- Generate test files of arbitrary size
- Custom Gomega matchers for log assertions"
```

---

### Phase 3: Test Implementation with Ginkgo (12-16 hours)

**Step 3.1: Implement logs_test.go** (4-5 hours)

**File**: `e2e/logs_test.go` (< 500 lines, split into multiple Describe blocks)

```go
package e2e

import (
    "context"

    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"

    "github.com/flanksource/commons-db/e2e/helpers"
    "github.com/flanksource/commons-db/logs/opensearch"
    "github.com/flanksource/commons-db/logs/loki"
)

var _ = Describe("Log Backends", func() {
    var testLogs []helpers.LogEntry

    BeforeEach(func() {
        testLogs = helpers.GenerateTestLogs(100)
    })

    Describe("OpenSearch", func() {
        var searcher *opensearch.Searcher

        BeforeEach(func() {
            cfg := &opensearch.Config{
                URL:   serviceManager.OpenSearchURL(),
                Index: "test-logs",
            }
            searcher = opensearch.NewSearcher(cfg)

            // Ingest test logs
            err := helpers.IngestToOpenSearch(searcher, testLogs)
            Expect(err).NotTo(HaveOccurred())

            // Wait for indexing
            time.Sleep(2 * time.Second)
        })

        Context("searching logs", func() {
            It("should find logs by exact field match", func() {
                results, err := searcher.Search(ctx, opensearch.SearchRequest{
                    Query: "level=error",
                    Size:  10,
                })
                Expect(err).NotTo(HaveOccurred())
                Expect(results.Logs).NotTo(BeEmpty())

                for _, log := range results.Logs {
                    Expect(log.Labels).To(HaveKeyWithValue("level", "error"))
                }
            })

            It("should support wildcard searches", func() {
                results, err := searcher.Search(ctx, opensearch.SearchRequest{
                    Query: "service=api*",
                    Size:  50,
                })
                Expect(err).NotTo(HaveOccurred())

                for _, log := range results.Logs {
                    Expect(log.Labels["service"]).To(HavePrefix("api"))
                }
            })

            It("should handle JSON field preprocessing", func() {
                // Test @json field handling
                logWithJSON := helpers.LogEntry{
                    Message: "config log",
                    Labels: map[string]string{
                        "config@json": `{"env":"test","port":8080}`,
                    },
                }

                err := helpers.IngestToOpenSearch(searcher, []helpers.LogEntry{logWithJSON})
                Expect(err).NotTo(HaveOccurred())

                time.Sleep(2 * time.Second)

                results, err := searcher.Search(ctx, opensearch.SearchRequest{
                    Query: "config@json.env=test",
                    Size:  1,
                })
                Expect(err).NotTo(HaveOccurred())
                Expect(results.Logs).To(HaveLen(1))
            })
        })

        Context("retrieving logs by ID", func() {
            It("should retrieve specific log entry", func() {
                // First search to get an ID
                results, err := searcher.Search(ctx, opensearch.SearchRequest{
                    Query: "level=info",
                    Size:  1,
                })
                Expect(err).NotTo(HaveOccurred())
                Expect(results.Logs).To(HaveLen(1))

                logID := results.Logs[0].ID

                // Retrieve by ID
                log, err := searcher.GetByID(ctx, logID)
                Expect(err).NotTo(HaveOccurred())
                Expect(log.ID).To(Equal(logID))
            })
        })
    })

    Describe("Loki", func() {
        var client *loki.Client

        BeforeEach(func() {
            cfg := &loki.Config{
                URL: serviceManager.LokiURL(),
            }
            client = loki.NewClient(cfg)

            // Push test logs
            err := helpers.PushToLoki(client, testLogs)
            Expect(err).NotTo(HaveOccurred())
        })

        Context("querying with LogQL", func() {
            It("should query logs by label", func() {
                query := `{service="api"}`
                results, err := client.Query(ctx, loki.QueryRequest{
                    Query: query,
                    Limit: 100,
                })
                Expect(err).NotTo(HaveOccurred())

                for _, log := range results.Logs {
                    Expect(log.Labels).To(HaveKeyWithValue("service", "api"))
                }
            })

            It("should support label filtering", func() {
                query := `{level="error"} |= "message"`
                results, err := client.Query(ctx, loki.QueryRequest{
                    Query: query,
                })
                Expect(err).NotTo(HaveOccurred())

                for _, log := range results.Logs {
                    Expect(log.Labels["level"]).To(Equal("error"))
                    Expect(log.Message).To(ContainSubstring("message"))
                }
            })
        })

        Context("with time range queries", func() {
            It("should filter by time range", func() {
                now := time.Now()
                start := now.Add(-1 * time.Hour)

                results, err := client.QueryRange(ctx, loki.QueryRangeRequest{
                    Query: `{level="info"}`,
                    Start: start,
                    End:   now,
                })
                Expect(err).NotTo(HaveOccurred())

                for _, log := range results.Logs {
                    Expect(log.Timestamp).To(BeTemporally(">=", start))
                    Expect(log.Timestamp).To(BeTemporally("<=", now))
                }
            })
        })
    })

    Describe("Kubernetes Logs", func() {
        // Tests using envtest
        It("should retrieve pod logs via API", func() {
            Skip("Requires envtest setup")
        })
    })

    Describe("CloudWatch Logs via LocalStack", func() {
        It("should create log stream and write events", func() {
            Skip("Requires LocalStack CloudWatch setup")
        })
    })
})
```

**Verification**:
```bash
cd e2e
ginkgo -v -focus="Log Backends"
```

**Git**:
```bash
git add e2e/logs_test.go
git commit -m "feat(e2e): implement log backend integration tests

- OpenSearch: search, wildcard, JSON preprocessing
- Loki: LogQL queries, label filtering, time ranges
- Uses Ginkgo BDD structure with Context/It
- All tests use real service connections"
go test ./e2e -v
git tag wip-run
```

**Step 3.2: Implement connections_test.go** (4-5 hours)

**File**: `e2e/connections_test.go` (< 500 lines)

```go
package e2e

import (
    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"

    "github.com/flanksource/commons-db/connection"
    "github.com/flanksource/commons-db/e2e/helpers"
)

var _ = Describe("Connections", func() {
    Describe("SFTP", func() {
        var conn *connection.SFTPConnection
        var testData []byte

        BeforeEach(func() {
            conn = &connection.SFTPConnection{
                Host:     "localhost",
                Port:     dockerManager.SFTPPort(),
                Username: "test",
                Password: "test",
            }
            testData = helpers.GenerateTestFile(1024) // 1KB
        })

        It("should connect successfully", func() {
            err := conn.Connect(ctx)
            Expect(err).NotTo(HaveOccurred())
        })

        Context("file operations", func() {
            BeforeEach(func() {
                Expect(conn.Connect(ctx)).To(Succeed())
            })

            AfterEach(func() {
                conn.Close()
            })

            It("should upload a file", func() {
                err := conn.Upload(ctx, "/test-upload.txt", testData)
                Expect(err).NotTo(HaveOccurred())
            })

            It("should download an uploaded file", func() {
                err := conn.Upload(ctx, "/test-download.txt", testData)
                Expect(err).NotTo(HaveOccurred())

                downloaded, err := conn.Download(ctx, "/test-download.txt")
                Expect(err).NotTo(HaveOccurred())
                Expect(downloaded).To(Equal(testData))
            })

            It("should list files in directory", func() {
                Expect(conn.Upload(ctx, "/list-1.txt", testData)).To(Succeed())
                Expect(conn.Upload(ctx, "/list-2.txt", testData)).To(Succeed())

                files, err := conn.List(ctx, "/")
                Expect(err).NotTo(HaveOccurred())
                Expect(files).To(ContainElement("list-1.txt"))
                Expect(files).To(ContainElement("list-2.txt"))
            })

            It("should delete a file", func() {
                err := conn.Upload(ctx, "/test-delete.txt", testData)
                Expect(err).NotTo(HaveOccurred())

                err = conn.Delete(ctx, "/test-delete.txt")
                Expect(err).NotTo(HaveOccurred())

                _, err = conn.Download(ctx, "/test-delete.txt")
                Expect(err).To(HaveOccurred())
            })
        })
    })

    Describe("S3 via LocalStack", func() {
        var conn *connection.S3Connection

        BeforeEach(func() {
            conn = &connection.S3Connection{
                Endpoint:        serviceManager.LocalStackURL(),
                AccessKey:       "test",
                SecretKey:       "test",
                Region:          "us-east-1",
                DisableSSL:      true,
                ForcePathStyle:  true,
            }
        })

        It("should create a bucket", func() {
            err := conn.CreateBucket(ctx, "test-bucket")
            Expect(err).NotTo(HaveOccurred())
        })

        Context("object operations", func() {
            BeforeEach(func() {
                Expect(conn.CreateBucket(ctx, "test-objects")).To(Succeed())
            })

            It("should put and get object", func() {
                testData := []byte("S3 test content")

                err := conn.PutObject(ctx, "test-objects", "test.txt", testData)
                Expect(err).NotTo(HaveOccurred())

                retrieved, err := conn.GetObject(ctx, "test-objects", "test.txt")
                Expect(err).NotTo(HaveOccurred())
                Expect(retrieved).To(Equal(testData))
            })

            It("should list objects", func() {
                Expect(conn.PutObject(ctx, "test-objects", "file1.txt", []byte("1"))).To(Succeed())
                Expect(conn.PutObject(ctx, "test-objects", "file2.txt", []byte("2"))).To(Succeed())

                objects, err := conn.ListObjects(ctx, "test-objects", "")
                Expect(err).NotTo(HaveOccurred())
                Expect(objects).To(HaveLen(2))
            })
        })
    })

    Describe("SMB", func() {
        It("should connect and perform file operations", func() {
            Skip("SMB implementation pending")
        })
    })

    Describe("GCS via fake-gcs-server", func() {
        var conn *connection.GCSConnection

        BeforeEach(func() {
            conn = &connection.GCSConnection{
                Endpoint:   fmt.Sprintf("http://localhost:%d", dockerManager.GCSPort()),
                ProjectID:  "test-project",
            }
        })

        It("should create bucket", func() {
            err := conn.CreateBucket(ctx, "test-gcs-bucket")
            Expect(err).NotTo(HaveOccurred())
        })

        It("should upload and download objects", func() {
            Expect(conn.CreateBucket(ctx, "test-gcs")).To(Succeed())

            testData := []byte("GCS test content")
            err := conn.UploadObject(ctx, "test-gcs", "test.txt", testData)
            Expect(err).NotTo(HaveOccurred())

            retrieved, err := conn.DownloadObject(ctx, "test-gcs", "test.txt")
            Expect(err).NotTo(HaveOccurred())
            Expect(retrieved).To(Equal(testData))
        })
    })

    Describe("Azure via Azurite", func() {
        var conn *connection.AzureConnection

        BeforeEach(func() {
            conn = &connection.AzureConnection{
                ConnectionString: fmt.Sprintf(
                    "DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://localhost:%d/devstoreaccount1;",
                    dockerManager.AzuriteBlobPort(),
                ),
            }
        })

        It("should create container", func() {
            err := conn.CreateContainer(ctx, "test-container")
            Expect(err).NotTo(HaveOccurred())
        })

        It("should upload and download blobs", func() {
            Expect(conn.CreateContainer(ctx, "test-blobs")).To(Succeed())

            testData := []byte("Azure test content")
            err := conn.UploadBlob(ctx, "test-blobs", "test.txt", testData)
            Expect(err).NotTo(HaveOccurred())

            retrieved, err := conn.DownloadBlob(ctx, "test-blobs", "test.txt")
            Expect(err).NotTo(HaveOccurred())
            Expect(retrieved).To(Equal(testData))
        })
    })
})
```

**Verification**:
```bash
ginkgo -v -focus="Connections"
```

**Git**:
```bash
git add e2e/connections_test.go
git commit -m "feat(e2e): implement connection integration tests

- SFTP: upload, download, list, delete
- S3 via LocalStack: bucket and object operations
- GCS via fake-gcs-server: bucket and object operations
- Azure via Azurite: container and blob operations
- All tests use Ginkgo BDD structure"
go test ./e2e -v
git tag wip-run
```

**Step 3.3: Implement query_test.go** (2-3 hours)

**File**: `e2e/query_test.go` (< 400 lines)

```go
package e2e

import (
    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"

    "github.com/flanksource/commons-db/query"
)

var _ = Describe("Query Grammar", func() {
    Describe("Parsing", func() {
        Context("simple field queries", func() {
            It("should parse type=value", func() {
                parsed, err := query.Parse("type=Kubernetes::Pod")
                Expect(err).NotTo(HaveOccurred())
                Expect(parsed.Fields).To(HaveKeyWithValue("type", "Kubernetes::Pod"))
            })

            It("should parse multiple fields", func() {
                parsed, err := query.Parse("type=Pod name=nginx namespace=default")
                Expect(err).NotTo(HaveOccurred())
                Expect(parsed.Fields).To(HaveLen(3))
                Expect(parsed.Fields).To(HaveKeyWithValue("type", "Pod"))
                Expect(parsed.Fields).To(HaveKeyWithValue("name", "nginx"))
                Expect(parsed.Fields).To(HaveKeyWithValue("namespace", "default"))
            })
        })

        Context("with comparison operators", func() {
            DescribeTable("should parse operators correctly",
                func(queryStr string, expectedField string, expectedOp string, expectedValue string) {
                    parsed, err := query.Parse(queryStr)
                    Expect(err).NotTo(HaveOccurred())

                    // Verify operator parsing
                    op := parsed.GetOperator(expectedField)
                    Expect(op).To(Equal(expectedOp))
                    Expect(parsed.Fields[expectedField]).To(Equal(expectedValue))
                },
                Entry("greater than", "age>5", "age", ">", "5"),
                Entry("less than", "age<10", "age", "<", "10"),
                Entry("greater than or equal", "age>=5", "age", ">=", "5"),
                Entry("less than or equal", "age<=10", "age", "<=", "10"),
                Entry("not equal", "status!=failed", "status", "!=", "failed"),
            )
        })

        Context("with wildcards", func() {
            It("should parse prefix wildcard", func() {
                parsed, err := query.Parse("name=nginx*")
                Expect(err).NotTo(HaveOccurred())
                Expect(parsed.IsWildcard("name")).To(BeTrue())
                Expect(parsed.WildcardType("name")).To(Equal("prefix"))
            })

            It("should parse suffix wildcard", func() {
                parsed, err := query.Parse("name=*pod")
                Expect(err).NotTo(HaveOccurred())
                Expect(parsed.IsWildcard("name")).To(BeTrue())
                Expect(parsed.WildcardType("name")).To(Equal("suffix"))
            })

            It("should parse contains wildcard", func() {
                parsed, err := query.Parse("name=*app*")
                Expect(err).NotTo(HaveOccurred())
                Expect(parsed.IsWildcard("name")).To(BeTrue())
                Expect(parsed.WildcardType("name")).To(Equal("contains"))
            })
        })

        Context("with date math", func() {
            DescribeTable("should parse date math expressions",
                func(queryStr string, expectedField string) {
                    parsed, err := query.Parse(queryStr)
                    Expect(err).NotTo(HaveOccurred())
                    Expect(parsed.IsDateMath(expectedField)).To(BeTrue())
                },
                Entry("now minus hours", "created_at>now-24h", "created_at"),
                Entry("now minus days", "updated_at<now-7d", "updated_at"),
                Entry("now minus weeks", "deleted_at>=now-2w", "deleted_at"),
                Entry("specific date", "created_at>2025-01-01", "created_at"),
            )
        })

        Context("with label selectors", func() {
            It("should parse simple label", func() {
                parsed, err := query.Parse("label.app=nginx")
                Expect(err).NotTo(HaveOccurred())
                Expect(parsed.Labels).To(HaveKeyWithValue("app", "nginx"))
            })

            It("should parse label selector expression", func() {
                parsed, err := query.Parse(`labelSelector="app in (nginx,apache)"`)
                Expect(err).NotTo(HaveOccurred())
                Expect(parsed.LabelSelector).NotTo(BeEmpty())
            })
        })

        Context("with complex queries", func() {
            It("should parse OR queries", func() {
                parsed, err := query.Parse("(type=Pod name=nginx) | type=Service")
                Expect(err).NotTo(HaveOccurred())
                Expect(parsed.IsComplex()).To(BeTrue())
            })

            It("should parse AND with parentheses", func() {
                parsed, err := query.Parse("(type=Pod status=Running) namespace=default")
                Expect(err).NotTo(HaveOccurred())
                // Verify parsed structure
            })
        })
    })

    Describe("Execution", func() {
        BeforeEach(func() {
            // Seed postgres with test data
            helpers.SeedCatalogData(serviceManager.PostgresConn())
        })

        It("should execute simple field query", func() {
            results, err := query.Execute(ctx, serviceManager.PostgresConn(), "type=Pod")
            Expect(err).NotTo(HaveOccurred())
            Expect(results).NotTo(BeEmpty())

            for _, r := range results {
                Expect(r.Type).To(Equal("Pod"))
            }
        })

        It("should execute wildcard query", func() {
            results, err := query.Execute(ctx, serviceManager.PostgresConn(), "name=nginx*")
            Expect(err).NotTo(HaveOccurred())

            for _, r := range results {
                Expect(r.Name).To(HavePrefix("nginx"))
            }
        })

        It("should execute date math query", func() {
            results, err := query.Execute(ctx, serviceManager.PostgresConn(), "created_at>now-24h")
            Expect(err).NotTo(HaveOccurred())

            now := time.Now()
            cutoff := now.Add(-24 * time.Hour)

            for _, r := range results {
                Expect(r.CreatedAt).To(BeTemporally(">", cutoff))
            }
        })
    })
})
```

**Verification**:
```bash
ginkgo -v -focus="Query Grammar"
```

**Git**:
```bash
git add e2e/query_test.go
git commit -m "feat(e2e): implement query grammar tests

- Parse field queries, operators, wildcards
- Parse date math and label selectors
- Execute queries against postgres
- Use DescribeTable for parameterized tests"
go test ./e2e -v
git tag wip-run
```

**Step 3.4: Implement secrets_test.go** (1-2 hours)

**File**: `e2e/secrets_test.go` (< 300 lines)

```go
package e2e

import (
    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"

    "github.com/flanksource/commons-db/secret"
)

var _ = Describe("Secret Management", func() {
    Describe("SecretKeeper", func() {
        It("should store and retrieve secrets", func() {
            Skip("SecretKeeper implementation pending")
        })
    })

    Describe("Sensitive Data", func() {
        It("should redact sensitive fields", func() {
            data := map[string]interface{}{
                "username": "admin",
                "password": "secret123",
                "apiKey":   "key-12345",
            }

            redacted := secret.RedactSensitive(data)
            Expect(redacted["password"]).To(Equal("***REDACTED***"))
            Expect(redacted["apiKey"]).To(Equal("***REDACTED***"))
            Expect(redacted["username"]).To(Equal("admin"))
        })
    })
})
```

**Git**:
```bash
git add e2e/secrets_test.go
git commit -m "feat(e2e): implement secret management tests

- Test secret storage and retrieval
- Test sensitive data redaction"
```

**Step 3.5: Run full test suite** (1 hour)

```bash
cd e2e
ginkgo -v --timeout=15m
```

**Verification**: All tests pass

**Git**:
```bash
git tag wip-pass
```

---

### Phase 4: CI Integration (4-6 hours)

**Step 4.1: Create GitHub Actions workflow** (2-3 hours)

**File**: `.github/workflows/e2e.yml`

```yaml
name: E2E Tests

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
          cache: true

      - name: Install Ginkgo CLI
        run: go install github.com/onsi/ginkgo/v2/ginkgo@latest

      - name: Install deps CLI
        run: |
          curl -L https://github.com/flanksource/deps/releases/latest/download/deps_linux_amd64 -o /tmp/deps
          chmod +x /tmp/deps
          sudo mv /tmp/deps /usr/local/bin/deps
          deps --version

      - name: Install service dependencies
        working-directory: e2e
        run: |
          deps install
          ls -la .bin/

      - name: Start Docker services
        run: docker compose -f e2e/docker-compose.yml up -d

      - name: Wait for Docker services
        run: |
          timeout 60 bash -c 'until docker ps | grep -q "Up.*sftp"; do sleep 2; done'
          timeout 60 bash -c 'until docker ps | grep -q "Up.*azurite"; do sleep 2; done'

      - name: Run E2E tests with Ginkgo
        working-directory: e2e
        run: |
          ginkgo -v --timeout=15m --junit-report=test-results.xml --cover --coverprofile=coverage.out

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            e2e/test-results.xml
            e2e/coverage.out

      - name: Publish test report
        uses: mikepenz/action-junit-report@v4
        if: always()
        with:
          report_paths: 'e2e/test-results.xml'
          check_name: E2E Test Results

      - name: Cleanup
        if: always()
        run: |
          docker compose -f e2e/docker-compose.yml down -v || true
          cd e2e && deps uninstall || true
```

**Git**:
```bash
git add .github/workflows/e2e.yml
git commit -m "ci: add E2E test workflow with Ginkgo

- Install deps and services
- Start Docker containers
- Run Ginkgo specs with JUnit reporting
- Upload test results and coverage"
```

**Step 4.2: Create docker-compose.yml** (1 hour)

**File**: `e2e/docker-compose.yml`

```yaml
version: '3.8'

services:
  sftp:
    image: atmoz/sftp:latest
    container_name: e2e-sftp
    ports:
      - "2222:22"
    command: test:test:1001
    healthcheck:
      test: ["CMD", "nc", "-z", "localhost", "22"]
      interval: 5s
      timeout: 3s
      retries: 10

  smb:
    image: filesysorg/jfileserver:latest
    container_name: e2e-smb
    ports:
      - "445:445"
    healthcheck:
      test: ["CMD", "nc", "-z", "localhost", "445"]
      interval: 5s
      timeout: 3s
      retries: 10

  fake-gcs:
    image: fsouza/fake-gcs-server:latest
    container_name: e2e-gcs
    ports:
      - "4443:4443"
    command: ["-scheme", "http", "-public-host", "localhost:4443"]
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:4443/"]
      interval: 5s
      timeout: 3s
      retries: 10

  azurite:
    image: mcr.microsoft.com/azure-storage/azurite:latest
    container_name: e2e-azurite
    ports:
      - "10000:10000"  # Blob
      - "10001:10001"  # Queue
      - "10002:10002"  # Table
    command: azurite --blobHost 0.0.0.0 --queueHost 0.0.0.0 --tableHost 0.0.0.0
    healthcheck:
      test: ["CMD", "nc", "-z", "localhost", "10000"]
      interval: 5s
      timeout: 3s
      retries: 10
```

**Git**:
```bash
git add e2e/docker-compose.yml
git commit -m "ci: add docker-compose for E2E services

- SFTP, SMB, GCS, Azurite containers
- Health checks for all services
- Port mappings for local and CI"
```

**Step 4.3: Create E2E README** (1-2 hours)

**File**: `e2e/README.md`

````markdown
# Commons-DB E2E Tests

End-to-end tests for commons-db using Ginkgo test framework.

## Prerequisites

- Go 1.22+
- Docker
- [Ginkgo CLI](https://github.com/onsi/ginkgo): `go install github.com/onsi/ginkgo/v2/ginkgo@latest`
- [flanksource/deps](https://github.com/flanksource/deps): For installing service dependencies

## Installation

1. Install Ginkgo CLI:
```bash
go install github.com/onsi/ginkgo/v2/ginkgo@latest
```

2. Install deps CLI:
```bash
# macOS
curl -L https://github.com/flanksource/deps/releases/latest/download/deps_darwin_arm64 -o /usr/local/bin/deps

# Linux
curl -L https://github.com/flanksource/deps/releases/latest/download/deps_linux_amd64 -o /usr/local/bin/deps

chmod +x /usr/local/bin/deps
```

3. Install service dependencies:
```bash
cd e2e
deps install
```

4. Start Docker services:
```bash
docker compose up -d
```

## Running Tests

### Run all tests:
```bash
cd e2e
ginkgo -v
```

### Run specific test file:
```bash
ginkgo -v logs_test.go
```

### Run specific test by focus:
```bash
ginkgo -v --focus="OpenSearch"
ginkgo -v --focus="SFTP"
ginkgo -v --focus="Query Grammar"
```

### Run with coverage:
```bash
ginkgo -v --cover --coverprofile=coverage.out
go tool cover -html=coverage.out
```

### Run in parallel (if tests support it):
```bash
ginkgo -v -p
```

## Test Organization

- `e2e_suite_test.go` - Ginkgo suite setup, starts/stops all services
- `logs_test.go` - Log backend tests (OpenSearch, Loki, K8s, CloudWatch)
- `connections_test.go` - Connection tests (SFTP, S3, SMB, GCS, Azure)
- `query_test.go` - Query grammar parsing and execution
- `secrets_test.go` - Secret management tests
- `helpers/` - Service management, fixtures, custom matchers

## Service Ports

| Service | Port | Usage |
|---------|------|-------|
| Postgres | 5432 | Database for test fixtures |
| Redis | 6379 | Caching and pub/sub |
| OpenSearch | 9200 | Log search and indexing |
| Loki | 3100 | Log aggregation |
| LocalStack | 4566 | AWS service emulation |
| SFTP | 2222 | SFTP server |
| SMB | 445 | SMB file sharing |
| Fake GCS | 4443 | GCS emulation |
| Azurite Blob | 10000 | Azure Blob Storage |
| Azurite Queue | 10001 | Azure Queue Storage |
| Azurite Table | 10002 | Azure Table Storage |

## Debugging

### View service logs:
```bash
# Native services
tail -f .data/postgres/postgres.log
tail -f .data/opensearch/logs/opensearch.log

# Docker services
docker compose logs -f sftp
docker compose logs -f azurite
```

### Check service health:
```bash
# Postgres
.bin/psql -h localhost -p 5432 -U postgres -c "SELECT version();"

# Redis
.bin/redis-cli ping

# OpenSearch
curl http://localhost:9200

# Loki
curl http://localhost:3100/ready

# LocalStack
aws --endpoint-url=http://localhost:4566 s3 ls
```

### Clean up services:
```bash
# Stop Docker containers
docker compose down -v

# Stop native services (if orphaned)
pkill -f redis-server
pkill -f opensearch
pkill -f loki
pkill -f localstack

# Clean data directories
rm -rf .data/
```

## CI Integration

E2E tests run automatically on:
- Every pull request
- Pushes to main branch
- Manual workflow dispatch

See `.github/workflows/e2e.yml` for CI configuration.

## Troubleshooting

### "Port already in use" errors:
```bash
# Find and kill process using port 9200 (OpenSearch)
lsof -ti:9200 | xargs kill -9
```

### "Docker container won't start":
```bash
# Check Docker logs
docker compose logs [service-name]

# Remove all containers and volumes
docker compose down -v
docker compose up -d
```

### "Tests timeout":
- Increase timeout: `ginkgo -v --timeout=30m`
- Check service health before running tests
- Verify Docker has sufficient resources (4GB+ RAM)

### "Ginkgo not found":
```bash
go install github.com/onsi/ginkgo/v2/ginkgo@latest
export PATH=$PATH:$(go env GOPATH)/bin
```

## Contributing

When adding new tests:
1. Follow Ginkgo BDD structure (Describe/Context/It)
2. Use Gomega matchers (Expect, Eventually, Consistently)
3. Keep test files under 500 lines
4. Add fixtures to `helpers/fixtures.go`
5. Create custom matchers in `helpers/assertions.go` if needed
6. Update this README with new test coverage

## References

- [Ginkgo Documentation](https://onsi.github.io/ginkgo/)
- [Gomega Matchers](https://onsi.github.io/gomega/)
- [Flanksource Deps](https://github.com/flanksource/deps)
- [Testcontainers Go](https://golang.testcontainers.org/)
````

**Git**:
```bash
git add e2e/README.md
git commit -m "docs: add comprehensive E2E testing documentation

- Setup instructions with deps and Ginkgo
- Running tests locally and in CI
- Service ports and debugging tips
- Troubleshooting common issues"
```

**Step 4.4: Test CI workflow** (1 hour)

1. Push branch:
```bash
git push origin add-e2e-testing
```

2. Create pull request
3. Verify workflow runs successfully
4. Check test results in PR

**Git** (after successful CI run):
```bash
git tag e2e-v1.0
```

---

## 6. Testing Strategy

### TDD Approach

**Before writing any implementation**:
1. Write Ginkgo specs that describe desired behavior
2. Run specs - they should fail (red)
3. Implement minimum code to make specs pass (green)
4. Refactor while keeping specs green

### Ginkgo Test Structure

**Use BDD organization**:
```go
Describe("Feature", func() {       // What you're testing
    Context("Scenario", func() {   // Specific scenario
        It("Behavior", func() {    // Expected behavior
            // Test implementation
        })
    })
})
```

### Gomega Matchers

**Prefer descriptive matchers**:
```go
// Good
Expect(results).To(HaveLen(10))
Expect(log.Level).To(Equal("error"))
Expect(conn.IsHealthy()).To(BeTrue())

// Avoid
Expect(len(results) == 10).To(BeTrue())
Expect(log.Level == "error").To(BeTrue())
```

### Test Data Management

**Fixtures**:
- Generate realistic test data
- Use consistent seeds for reproducibility
- Clean up after each test (AfterEach)

**Database**:
- Seed postgres in BeforeSuite
- Use transactions for test isolation
- Reset state in AfterEach

### Performance

**Timeout configuration**:
```go
It("should complete quickly", func() {
    Eventually(func() bool {
        return service.IsReady()
    }, "30s", "1s").Should(BeTrue())
})
```

**Parallel execution** (when tests are independent):
```bash
ginkgo -v -p --procs=4
```

---

## 7. CLAUDE.md Compliance Checklist

### Before Coding (BP-1 to BP-3)
- ‚úÖ **BP-1**: 6 clarifying questions asked during discovery
- ‚úÖ **BP-2**: Approach confirmed (Ginkgo, native binaries, Docker containers)
- ‚úÖ **BP-3**: Alternatives considered (Docker vs native, Ginkgo vs stdlib, test organization)

### While Coding (C-1 to C-13)
- ‚úÖ **C-1**: TDD - Write Ginkgo specs before implementation
- ‚úÖ **C-2**: Use existing vocabulary (Searcher, Connection, ServiceManager)
- ‚úÖ **C-4**: Simple, composable functions
- ‚úÖ **C-5**: Minimal comments, rely on descriptive Ginkgo specs
- ‚úÖ **C-7**: Extract functions only when reused or for testability
- ‚úÖ **C-8**: No file > 500 lines, no function > 50 lines
- ‚úÖ **C-10**: Named arguments for functions with >2 params
- ‚úÖ **C-11**: Prefer short, concise code
- ‚úÖ **C-13**: No duplicate code or function overloading

### Testing (T-1 to T-6)
- ‚úÖ **T-1**: Unit tests colocated in `*_test.go` files
- ‚úÖ **T-2**: Integration tests in e2e directory
- ‚úÖ **T-3**: Pure-logic tests separate from integration tests
- ‚úÖ **T-4**: Prefer integration tests over heavy mocking
- ‚úÖ **T-5**: Query grammar tested thoroughly with DescribeTable
- ‚úÖ **T-6**: Test entire structure with Gomega matchers

### Tooling (G-1 to G-2)
- ‚úÖ **G-1**: Run `make lint` on all new code
- ‚úÖ **G-2**: Run `make build` to verify compilation

### Git (GH-1 to GH-2)
- ‚úÖ **GH-1**: Use Conventional Commits format
- ‚úÖ **GH-2**: No Claude/Anthropic references
- ‚úÖ **GH-2**: Individual file git adds (no `git add .`)
- ‚úÖ **GH-2**: Apply tags after milestones:
  - `wip-compile` after successful compilation
  - `wip-run` after successful test execution
  - `wip-pass` after all tests pass
- ‚úÖ **GH-2**: Break into logical commits (1-2 line messages)

---

## 8. Success Metrics

### Quantitative Metrics

- ‚úÖ All 4 new deps packages install successfully (4/4)
- ‚úÖ E2E test coverage ‚â• 80% of integration points:
  - Log backends: 4/6 (OpenSearch, Loki, K8s via envtest, CloudWatch via LocalStack)
  - Connections: 5/8 (SFTP, S3, GCS, Azure, K8s)
  - Query grammar: Full coverage
  - Secrets: Basic coverage
- ‚úÖ Test suite execution time < 10 minutes
- ‚úÖ Zero flaky tests (100% deterministic)
- ‚úÖ CI workflow success rate ‚â• 95%
- ‚úÖ Test coverage reported in CI
- ‚úÖ Ginkgo JUnit reports generated

### Qualitative Metrics

- ‚úÖ Developers can run tests with single command: `ginkgo -v`
- ‚úÖ Test failures provide actionable error messages via Ginkgo output
- ‚úÖ Service lifecycle is reliable (no orphaned processes/containers)
- ‚úÖ Documentation is clear and comprehensive
- ‚úÖ Tests serve as living documentation via BDD structure
- ‚úÖ Ginkgo specs are readable and maintainable

---

## 9. Risks & Mitigations

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Upstream deps PR delayed | Medium | Medium | Use local deps.yaml in commons-db/e2e temporarily |
| Services require too much memory | High | Low | Use minimal configurations, lazy startup, on-demand services |
| Docker unavailable in some environments | Medium | Medium | Add build tags to skip Docker-dependent tests |
| Flaky tests due to timing issues | High | Medium | Implement robust health checks with Eventually(), add retries |
| OpenSearch requires significant disk | Medium | Low | Use in-memory storage, small index shards for tests |
| CloudWatch emulation incomplete | Low | Medium | Document limitations, mark experimental tests with Skip() |
| Ginkgo learning curve for contributors | Low | Medium | Provide examples in README, use consistent patterns |
| CI runner resource constraints | Medium | Low | Optimize service configs, use Docker resource limits |

---

## 10. Dependencies

### External Dependencies

- **flanksource/deps** - Service installation and management
- **Docker** - Container orchestration for SFTP, SMB, GCS, Azurite
- **Go 1.22+** - Test execution runtime
- **Ginkgo v2** - BDD test framework
- **Gomega** - Matcher library
- **testcontainers-go** - Docker container management
- **GitHub Actions** - CI/CD platform

### Internal Dependencies (commons-db packages)

- `logs/*` - Log backend implementations
- `logs/opensearch` - OpenSearch integration
- `logs/loki` - Loki integration
- `logs/k8s` - Kubernetes log retrieval
- `connection/*` - Connection implementations
- `connection/sftp` - SFTP connections
- `connection/s3` - S3 connections
- `connection/smb` - SMB connections
- `connection/gcs` - GCS connections
- `connection/azure` - Azure connections
- `secret` - Secret management
- `query/grammar` - Query parsing and execution

---

## 11. Future Enhancements

**Not in Scope for Initial Implementation**:
- Performance benchmarking (measure throughput, latency)
- Load testing with > 100K logs
- Multi-cluster Kubernetes testing
- Real cloud service testing (AWS, GCP, Azure with credentials)
- Chaos engineering (random service failures, network partitions)
- Security scanning of test environments
- Stress testing with concurrent operations
- Memory profiling and leak detection

**Potential Follow-up Work** (Priority Order):
1. **Add performance regression tests** - Detect performance degradations
2. **Implement test data archiving** - Save test results for historical analysis
3. **Create visual test reports** - Graphical representation of test trends
4. **Add support for Windows testing** - Windows-specific containers and services
5. **Implement distributed tracing** - Trace test execution across services
6. **Add mutation testing** - Verify test quality by introducing bugs
7. **Create test fixtures library** - Reusable test data across projects
8. **Add contract testing** - Verify API contracts between services

---

## 12. Appendix

### A. Service Port Assignments

| Service | Port | Protocol | Purpose | Health Check |
|---------|------|----------|---------|--------------|
| Postgres | 5432 | TCP | Database | `pg_isready` |
| Redis | 6379 | TCP | Cache/Pub-Sub | `redis-cli ping` |
| OpenSearch | 9200 | HTTP | REST API | `GET /_cluster/health` |
| OpenSearch | 9300 | TCP | Node comms | N/A |
| Loki | 3100 | HTTP | Query API | `GET /ready` |
| LocalStack | 4566 | HTTP | AWS services | `GET /health` |
| SFTP | 2222 | SSH | SFTP server | `nc -z localhost 2222` |
| SMB | 445 | TCP | SMB server | `nc -z localhost 445` |
| Fake GCS | 4443 | HTTP | GCS emulation | `GET /` |
| Azurite Blob | 10000 | HTTP | Blob storage | `nc -z localhost 10000` |
| Azurite Queue | 10001 | HTTP | Queue storage | `nc -z localhost 10001` |
| Azurite Table | 10002 | HTTP | Table storage | `nc -z localhost 10002` |
| envtest API | Random | HTTPS | K8s API | `/healthz` |

### B. Deps Package Definitions (Complete Examples)

**Redis** (with compilation):
```yaml
redis:
  name: redis
  manager: direct
  mode: directory
  url_template: https://download.redis.io/releases/redis-{{.version}}.tar.gz
  asset_patterns:
    "*": redis-{{.version}}.tar.gz
  version_command: src/redis-server --version
  version_pattern: 'Redis server v=(\d+\.\d+\.\d+)'
  post_process:
    - make -j4  # Compile with 4 cores
  symlinks:
    - src/redis-server
    - src/redis-cli
    - src/redis-benchmark
```

**OpenSearch** (with security disabled):
```yaml
opensearch:
  name: opensearch
  manager: direct
  mode: directory
  url_template: https://artifacts.opensearch.org/releases/bundle/opensearch/{{.version}}/opensearch-{{.version}}-{{.os}}-{{.arch}}.tar.gz
  asset_patterns:
    darwin-amd64: opensearch-{{.version}}-darwin-x64.tar.gz
    darwin-arm64: opensearch-{{.version}}-darwin-arm64.tar.gz
    linux-amd64: opensearch-{{.version}}-linux-x64.tar.gz
    linux-arm64: opensearch-{{.version}}-linux-arm64.tar.gz
  version_command: bin/opensearch --version
  version_pattern: 'Version: (\d+\.\d+\.\d+)'
  post_process:
    # Disable security plugin for testing
    - 'echo "plugins.security.disabled: true" >> config/opensearch.yml'
    # Set single node discovery
    - 'echo "discovery.type: single-node" >> config/opensearch.yml'
    # Set heap size
    - 'echo "-Xms512m" >> config/jvm.options'
    - 'echo "-Xmx512m" >> config/jvm.options'
  symlinks:
    - bin/opensearch
    - bin/opensearch-plugin
```

**Loki**:
```yaml
loki:
  name: loki
  repo: grafana/loki
  manager: github_release
  asset_patterns:
    darwin-amd64: loki-darwin-amd64.zip
    darwin-arm64: loki-darwin-arm64.zip
    linux-amd64: loki-linux-amd64.zip
    linux-arm64: loki-linux-arm64.zip
  version_command: --version
  version_pattern: 'loki, version (\d+\.\d+\.\d+)'
  checksum_file: SHA256SUMS
```

**LocalStack CLI**:
```yaml
localstack:
  name: localstack
  repo: localstack/localstack-cli
  manager: github_release
  asset_patterns:
    darwin-amd64: localstack-cli-{{.version}}-darwin-amd64.tar.gz
    darwin-arm64: localstack-cli-{{.version}}-darwin-arm64.tar.gz
    linux-amd64: localstack-cli-{{.version}}-linux-amd64.tar.gz
    linux-arm64: localstack-cli-{{.version}}-linux-arm64.tar.gz
  version_command: --version
  version_pattern: 'localstack (\d+\.\d+\.\d+)'
```

### C. Ginkgo Best Practices

**1. Use Descriptive Test Names**:
```go
// Good
It("should successfully connect to SFTP server", func() { ... })

// Avoid
It("test SFTP", func() { ... })
```

**2. Use Context for Scenarios**:
```go
Describe("SFTP Connection", func() {
    Context("when credentials are valid", func() {
        It("should connect successfully", func() { ... })
    })

    Context("when credentials are invalid", func() {
        It("should return authentication error", func() { ... })
    })
})
```

**3. Use BeforeEach for Setup**:
```go
var conn *SFTPConnection

BeforeEach(func() {
    conn = NewSFTPConnection(config)
})
```

**4. Use AfterEach for Cleanup**:
```go
AfterEach(func() {
    if conn != nil {
        conn.Close()
    }
})
```

**5. Use Eventually for Async Operations**:
```go
Eventually(func() bool {
    return service.IsHealthy()
}, "30s", "1s").Should(BeTrue())
```

**6. Use DescribeTable for Parameterized Tests**:
```go
DescribeTable("should parse operators",
    func(query string, expected string) {
        result, _ := Parse(query)
        Expect(result).To(Equal(expected))
    },
    Entry("greater than", "age>5", "5"),
    Entry("less than", "age<10", "10"),
)
```

### D. References

- [Ginkgo Documentation](https://onsi.github.io/ginkgo/)
- [Gomega Matcher Reference](https://onsi.github.io/gomega/)
- [Flanksource Deps](https://github.com/flanksource/deps)
- [Testcontainers Go](https://golang.testcontainers.org/)
- [OpenSearch Documentation](https://opensearch.org/docs/latest/)
- [Grafana Loki Documentation](https://grafana.com/docs/loki/latest/)
- [LocalStack Documentation](https://docs.localstack.cloud/)
- [envtest Documentation](https://book.kubebuilder.io/reference/envtest.html)
- [Conventional Commits](https://www.conventionalcommits.org/)

---

## 13. Traceability

### Git Commit Format

All commits related to e2e testing should follow this format:

```
<type>(<scope>): <description>

Implements <AC-number> from specs/2025-10-15-e2e-testing.md
<Optional detailed description>

Related: #<issue-number>
```

**Examples**:
```
feat(e2e): implement OpenSearch integration tests

Implements AC-3 (Log Backend Tests) from specs/2025-10-15-e2e-testing.md
Tests OpenSearch log ingestion, search with wildcards, and JSON field preprocessing.
Uses Ginkgo BDD structure with Context and It blocks.

Related: #123
```

```
feat(registry): add Redis package to deps

Implements AC-1 (Deps Contributions) from specs/2025-10-15-e2e-testing.md
Adds Redis 7.2.x with native compilation support for all platforms.

Related: #124
```

### Design Pivots

If major design changes occur during implementation, document here:

| Date | Change | Reason | Impact |
|------|--------|--------|--------|
| TBD | Switched from stdlib testing to Ginkgo | Better BDD structure, more readable specs | All test files refactored |
| TBD | TBD | TBD | TBD |

### Implementation Tracking

Track progress against acceptance criteria:

- [ ] AC-1: All 4 deps packages added
  - [ ] Redis
  - [ ] OpenSearch
  - [ ] Loki
  - [ ] LocalStack CLI
- [ ] AC-2: E2E infrastructure
  - [ ] Ginkgo suite setup
  - [ ] Service manager
  - [ ] Docker manager
  - [ ] Test fixtures
- [ ] AC-3: Log backend tests
  - [ ] OpenSearch
  - [ ] Loki
  - [ ] Kubernetes
  - [ ] CloudWatch
- [ ] AC-4: Connection tests
  - [ ] SFTP
  - [ ] S3
  - [ ] GCS
  - [ ] Azure
- [ ] AC-5: Query grammar tests
- [ ] AC-6: CI integration
- [ ] AC-7: Documentation

---

**End of Specification**

**Next Steps**:
1. Review specification with team
2. Approve and begin Phase 1: Deps Contributions
3. Follow implementation plan sequentially
4. Update this document with design pivots as needed
